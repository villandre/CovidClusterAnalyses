---
title: "Summarising phylogenetic output"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{resultsSummary}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(CovidClusterAnalyses)
```

We start by loading the data.
```{r, eval = FALSE}
library(ape)
library(stringr)
library(CovidCluster)

setwd("/media/permanentStorage/CovidProjectFiles")
# setwd("/home/luc/CovidProjectFiles/")

filesToImport <- list.files("outputFiles/", pattern = "sequencesToClusterFormattedForMrBayes", full.names = TRUE)
creationDateAsNumeric <- as.numeric(stringr::str_extract(filesToImport, "(?<=MrBayes_).+(?=\\.rds)"))
dataForAnalysisList <- readRDS(filesToImport[[which.max(creationDateAsNumeric)]])
```
The `covidCluster` function returns adjacency matrices based on a given cluster definition. We are interested in the extent to which clusters are affected based on cluster definition and threshold.
```{r, eval = FALSE}
# distLimitVec <- c(7, 14)
distLimitVec <- 21
# definitionsVec <- c("mrca", "cophenetic")
definitionsVec <- "mrca"
simulScenarios <- expand.grid(distance = distLimitVec, clusterDefinition = definitionsVec, stringsAsFactors = FALSE)
clustersByScenario <- 
  lapply(1:nrow(simulScenarios),
         FUN = function(scenarioIndex) {
           clusterFromMrBayesOutput(
             seqsTimestampsPOSIXct = dataForAnalysisList$timestamps, 
             seqsRegionStamps = dataForAnalysisList$regionStamps,
             MrBayesTreesFilename = "outputFiles/mrbayesData.nex.run1.t",
             # MrBayesParametersFilename = "outputFiles/mrbayesData.run1.p",
             clusterRegion = "quebec",
             clusterCriterion = simulScenarios$clusterDefinition[[scenarioIndex]],
             burninFraction = 0.75,
             linkageRequirement = 0.9,
             distLimit = simulScenarios$distance[[scenarioIndex]],
             epidemicRootTimePOSIXct = as.POSIXct("2019-12-15 EST"),
             perSiteClockRate = 2.4e-3, # Taken from Chaw 2020
             control = list(
               lengthForNullExtBranchesInPhylo = 1e-6,
               numReplicatesForClusMemScoring = 25,
               numThreads = 8,
               MrBayesOutputThinningRate = 0.1
             ))
         })
```
For each definition, we can then compute a cluster size distribution for the MAP clusters and the linkage clusters.
```{r, eval = FALSE}
summaryFct <- function(outputList) {
  MAPclusSizeDist <- table(table(outputList$MAPclusters))
  hierClusSizeDist <- table(table(outputList$hierarchicalClusters))
  overlap <- aricode::AMI(outputList$MAPclusters, outputList$hierarchicalClusters)
  list(MAPclusSizeDist = MAPclusSizeDist, hierClusSizeDist = hierClusSizeDist, overlap = overlap)
}
sizeDistributions <- lapply(clustersByScenario, summaryFct)
```
We now plot the adjacency matrices for the nine largest clusters.
```{r, eval = FALSE}
facettedPlot <- plotClustersTile(covidClusterObject = clustersByScenario[[1]], minClusSize = 15, textScaleFactor = 1, oneFilePerCluster = TRUE, numClusters = 16, outputFolder = "outputFiles/")
```



